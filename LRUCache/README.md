# Реализация LRU-кэша на C++

Реализуйте шаблонный класс `LRUCache<Key, Value>` (Least Recently Used Cache).
Кэш должен иметь фиксированную максимальную емкость.
При превышении емкости, необходимо удалить наименее недавно использованный элемент (LRU).
В классе должны быть следующие операции:

- `Get(key)`: Возвращает указатель на значение, связанное с ключом `key`. Если ключ отсутствует — возвращает `nullptr`.
- `Put(key, value)`: Вставляет или обновляет значение для ключа `key`.
- `GetValueOrDefault(key, factory)`: Если ключ отсутствует, вызывает функтор `factory` для создания нового значения, вставляет его в кэш (удаляя LRU-элемент при необходимости) и возвращает указатель на новое значение.

## Требования

1. **Методы**:
   - `Value* Get(const Key& key)`:
     - Возвращает указатель на значение, если ключ существует. Возвращённый элемент становится са
     - Возвращает `nullptr`, если ключ отсутствует.
   - `void Put(const Key& key, const Value& value)`:
     - Вставляет/обновляет значение для ключа.
     - Обновляет порядок использования.
   - `Value* GetValueOrDefault(const Key& key, std::function<Value()> factory)`: 
     - Если ключ отсутствует, вызывает `factory()` для создания нового значения, вставляет его в кэш и возвращает указатель.
     - Иначе возвращает указатель на существующее значение.
2. **Сложность операций**:
   - `Get`, `Put`, `GetValueOrDefault` должны выполняться за **O(1)** времени.
3. **Гарантии безопасности исключений**
   - Все методы класса должны обеспечивать **гарантию безопасности исключений не ниже базовой**.
     - Если без ухудшения производительности можно обеспечить более строгие гарантии, сделайте это.
   - Методы, которые всегда завершаются успешно, должны быть помечены `noexcept`.
4. **Поддержка копирования, перемещения и присваивания:**
   - Экземпляры класса `LRUCache` должны быть безопасно копируемыми и перемещаемыми,
     если типы `Key` и `Value` поддерживают эти операции.
   - После копирования внутренние структуры данных должны корректно копироваться.
     Копия кэша должна быть независимой от оригинала.
   - При перемещении все внутренние структуры должны переместиться, а оригинальный объект должен остаться в состоянии, в котором ему можно присвоить новое значение или безопасно разрушить.

## Пример использования

```cpp
#include <functional>
#include <iostream>

int main() {
    LRUCache<int, std::string> cache(2); // Емкость 2

    // Put
    cache.Put(1, "one");
    cache.Put(2, "two");

    // Get
    std::string* value = cache.Get(1);
    if (value) std::cout << *value << "\n"; // "one"
    value = cache.Get(3); // nullptr

    // GetValueOrDefault
    value = cache.GetValueOrDefault(3, []() { return "three"; });
    if (value) std::cout << *value << "\n"; // "three"

    value = cache.Get(2); // Удален, так как LRU
    if (!value) std::cout << "Key 2 not found\n";
}
```
